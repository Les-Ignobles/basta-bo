# Research: Administration des Abonnements et Codes Promo

**Feature**: 001-subscription-admin
**Date**: 2026-01-30

## 1. Accès à la table auth.users de Supabase

### Decision
Utiliser le Supabase Admin API via `supabaseServer` (service role key) pour accéder à `auth.users`.

### Rationale
- La table `auth.users` n'est pas accessible via les requêtes SQL classiques
- Le service role key permet d'utiliser `supabase.auth.admin.listUsers()` et `getUserById()`
- Pattern déjà utilisé dans le middleware d'authentification du projet

### Alternatives considérées
- **Vue SQL sur auth.users** : Rejeté - nécessite des migrations côté Supabase, plus complexe
- **Dupliquer l'email dans user_profiles** : Rejeté - déjà le cas partiellement mais pas fiable (peut être désynchronisé)

### Implementation
```typescript
// Recherche par email
const { data: { users } } = await supabaseServer.auth.admin.listUsers()
const user = users.find(u => u.email === searchEmail)

// Recherche par UUID
const { data: { user } } = await supabaseServer.auth.admin.getUserById(uuid)
```

---

## 2. Génération de codes promo uniques

### Decision
Générer des codes alphanumériques de 8 caractères en majuscules, avec retry automatique en cas de collision.

### Rationale
- 8 caractères alphanumériques (A-Z, 0-9) = 36^8 = ~2.8 trillion combinaisons
- Facile à lire et dicter par téléphone
- Format court pour copier/coller facilement

### Alternatives considérées
- **UUID** : Rejeté - trop long, difficile à communiquer
- **Code séquentiel (PROMO-001)** : Rejeté - révèle le nombre de codes générés
- **Nanoid** : Considéré mais custom plus simple pour ce cas

### Implementation
```typescript
function generatePromoCode(): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  let code = ''
  for (let i = 0; i < 8; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length))
  }
  return code
}

// Avec retry en cas de collision (constraint unique sur code)
async function createUniquePromoCode(payload: CreatePromoCodeDto): Promise<PromoCode> {
  const maxRetries = 3
  for (let i = 0; i < maxRetries; i++) {
    try {
      const code = generatePromoCode()
      return await repo.create({ ...payload, code })
    } catch (error) {
      if (i === maxRetries - 1) throw error
    }
  }
}
```

---

## 3. Calcul des dates d'abonnement

### Decision
- "1 mois" = +30 jours
- "1 an" = +365 jours
- Base de calcul : date actuelle de fin si premium actif, sinon aujourd'hui

### Rationale
- Cohérent avec les pratiques standard des abonnements
- Simple à comprendre pour l'administratrice
- Évite les complexités des mois calendaires (28-31 jours)

### Implementation
```typescript
function calculateNewEndDate(
  currentEndDate: Date | null,
  duration: '1_month' | '1_year'
): Date {
  const now = new Date()
  const baseDate = currentEndDate && currentEndDate > now
    ? currentEndDate
    : now

  const days = duration === '1_month' ? 30 : 365
  return new Date(baseDate.getTime() + days * 24 * 60 * 60 * 1000)
}
```

---

## 4. Structure de la table subscription_audit_logs

### Decision
Créer une nouvelle table pour stocker l'historique des modifications.

### Rationale
- FR-012 exige la traçabilité des actions
- Table séparée pour ne pas polluer `user_profiles`
- Permet des requêtes d'audit indépendantes

### Schema
```sql
CREATE TABLE subscription_audit_logs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  admin_id UUID NOT NULL,           -- UUID de l'admin qui fait l'action
  admin_email TEXT NOT NULL,        -- Email de l'admin (pour lisibilité)
  user_id UUID NOT NULL,            -- UUID de l'utilisateur modifié
  user_email TEXT NOT NULL,         -- Email de l'utilisateur (pour lisibilité)
  previous_end_date TIMESTAMPTZ,    -- Ancienne date de fin (null si jamais premium)
  new_end_date TIMESTAMPTZ NOT NULL,-- Nouvelle date de fin
  action_type TEXT NOT NULL         -- 'add_1_month', 'add_1_year', 'custom_date'
);

-- Index pour recherche par utilisateur
CREATE INDEX idx_subscription_audit_user_id ON subscription_audit_logs(user_id);
```

---

## 5. Permissions et sécurité

### Decision
Requérir le scope `admin:write` pour accéder aux deux pages.

### Rationale
- Modification de données sensibles (abonnements, données utilisateur)
- Cohérent avec le système de permissions existant
- Seuls les admins complets doivent pouvoir modifier des abonnements

### Implementation
```typescript
// Dans app-sidebar.tsx
{canAccessAdmin() && (
  <SidebarMenuItem>
    <SidebarMenuButton asChild>
      <Link href="/dashboard/subscriptions">
        <Users className="size-4" />
        <span>Abonnements</span>
      </Link>
    </SidebarMenuButton>
  </SidebarMenuItem>
)}

// Dans middleware - ajouter les routes
'/dashboard/subscriptions': ['admin:write'],
'/dashboard/promo-codes': ['admin:write'],
```

---

## 6. Pattern de recherche utilisateur

### Decision
Champ de recherche unique acceptant email ou UUID, détection automatique du type.

### Rationale
- UX simplifiée : un seul champ au lieu de deux
- UUID détectable par format (regex)
- L'administratrice n'a pas à réfléchir au type de recherche

### Implementation
```typescript
function isUUID(value: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)
}

async function searchUser(query: string) {
  if (isUUID(query)) {
    return searchByUUID(query)
  } else {
    return searchByEmail(query)
  }
}
```

---

## 7. Gestion du cas "utilisateur sans profil"

### Decision
Afficher un message explicatif avec option de créer un profil minimal.

### Rationale
- Edge case identifié dans la spec
- Certains utilisateurs peuvent exister dans auth.users sans avoir complété leur profil
- Permet quand même d'offrir un dédommagement

### Implementation
```typescript
// Si user existe dans auth.users mais pas dans user_profiles
if (authUser && !userProfile) {
  return {
    authUser,
    userProfile: null,
    canCreateProfile: true
  }
}

// Création de profil minimal
async function createMinimalProfile(authUser: User): Promise<UserProfile> {
  return await userProfileRepo.create({
    uuid: authUser.id,
    email: authUser.email,
    premium_sub_end_at: null
  })
}
```

---

## Résumé des décisions techniques

| Aspect | Décision |
|--------|----------|
| Accès auth.users | Supabase Admin API (service role) |
| Format codes promo | 8 caractères alphanumériques majuscules |
| Durée "1 mois" | 30 jours |
| Durée "1 an" | 365 jours |
| Audit logs | Nouvelle table `subscription_audit_logs` |
| Permissions | Scope `admin:write` requis |
| Recherche utilisateur | Champ unique avec détection auto email/UUID |
| User sans profil | Message + option création profil minimal |
